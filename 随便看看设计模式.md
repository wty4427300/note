# 策略模式

1. 策略接口
2. 实现策略的许多策略类
3. 不需要每次new新的类,使用map缓存type,和对应策略类
4. 需要new新的类,集中的if-else,或者switch-case.

# 工厂模式

是为了创建不同的类,而使用的设计模式

1. 工厂接口
2. 实现工厂接口的一些类
3. if-else返回
4. 可以使用map缓存对应的类
5. 可以使用工厂的工厂来创建,工厂的工厂可以使用map来做static初始化.

# 原型模式

就是深浅拷贝
浅拷贝:只拷贝基础数据类型和引用,指向的还是原来的对象.
深拷贝:拷贝整个对象的内存,生成新的对象

# 代理模式

## 静态代理

* 方法一:

1. 定义业务接口
2. 代理类实现业务接口
3. 原始类实现业务接口
4. 代理类构造函数传入原始类,作为一个成员变量
5. 代理类执行执行代理逻辑,然后执行原始类业务逻辑
   完成额外逻辑的代理

* 方法二:

代理类继承原始类重写原始类方法

## 动态代理

## jdk

JDK 动态代理是基于接口的代理，它利用 java.lang.reflect.Proxy 类和
InvocationHandler 接口实现动态代理。JDK 动态代理只能为接口创建代理对象，
对于没有实现接口的类无法使用 JDK 动态代理。

* 优点：使用简单，无需额外引入三方库
* 缺点：只能为实现了接口的类代理

## cglib

CGLIB 动态代理是基于类的代理，它利用字节码技术生成目标类的子类，并覆盖其中的方法实现代理。
因此，CGLIB 动态代理可以为没有实现接口的类创建代理对象。

* 优点： 可以代理类：CGLIB 动态代理可以为没有实现接口的类创建代理对象，扩展了代理的适用范围。
  性能较高：由于直接操作字节码生成子类，相比于 JDK 动态代理，CGLIB 动态代理在性能上通常更优。
* 复杂度较高：CGLIB 动态代理的实现较为复杂，需要引入第三方库。
  不支持 final 方法和类：由于 CGLIB 动态代理是通过生成子类实现代理的，因此无法代理被 final 修饰的方法和类。

# 桥接模式

将抽象和实现解耦，让它们可以独立变化

一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展

* 以jdbc举例

1. jdbc通过class.forName("驱动名")来加载
2. 不同的驱动名可以加载不同的Driver类
3. 不同的数据库实现不同的Driver类

## 装饰器模式
