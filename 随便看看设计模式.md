# 单例模式

# 建造者模式

# 策略模式

1. 策略接口
2. 实现策略的许多策略类
3. 不需要每次new新的类,使用map缓存type,和对应策略类
4. 需要new新的类,集中的if-else,或者switch-case.

# 工厂模式

是为了创建不同的类,而使用的设计模式

1. 工厂接口
2. 实现工厂接口的一些类
3. if-else返回
4. 可以使用map缓存对应的类
5. 可以使用工厂的工厂来创建,工厂的工厂可以使用map来做static初始化.

# 原型模式

就是深浅拷贝
浅拷贝:只拷贝基础数据类型和引用,指向的还是原来的对象.
深拷贝:拷贝整个对象的内存,生成新的对象

# 桥接模式

# 代理模式

## 静态代理

* 方法一:

1. 定义业务接口
2. 代理类实现业务接口
3. 原始类实现业务接口
4. 代理类构造函数传入原始类,作为一个成员变量
5. 代理类执行执行代理逻辑,然后执行原始类业务逻辑
   完成额外逻辑的代理

* 方法二:

代理类继承原始类重写原始类方法

## 动态代理

## jdk

JDK 动态代理是基于接口的代理，它利用 java.lang.reflect.Proxy 类和
InvocationHandler 接口实现动态代理。JDK 动态代理只能为接口创建代理对象，
对于没有实现接口的类无法使用 JDK 动态代理。

* 优点：使用简单，无需额外引入三方库
* 缺点：只能为实现了接口的类代理

## cglib

CGLIB 动态代理是基于类的代理，它利用字节码技术生成目标类的子类，并覆盖其中的方法实现代理。
因此，CGLIB 动态代理可以为没有实现接口的类创建代理对象。

* 优点： 可以代理类：CGLIB 动态代理可以为没有实现接口的类创建代理对象，扩展了代理的适用范围。
  性能较高：由于直接操作字节码生成子类，相比于 JDK 动态代理，CGLIB 动态代理在性能上通常更优。
* 复杂度较高：CGLIB 动态代理的实现较为复杂，需要引入第三方库。
  不支持 final 方法和类：由于 CGLIB 动态代理是通过生成子类实现代理的，因此无法代理被 final 修饰的方法和类。

# 桥接模式

将抽象和实现解耦，让它们可以独立变化

一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展

* 以jdbc举例

1. jdbc通过class.forName("驱动名")来加载
2. 不同的驱动名可以加载不同的Driver类
3. 不同的数据库实现不同的Driver类

# 装饰器模式

1. 装饰器类和原始类继承同样的父类
2. 装饰器类是对功能的增强

# 适配器模式

## 类适配器

通过继承实现

1. 子类继承需要适配的父类或接口
2. 子类实现被适配的接口。
3. 子类在需要实现的接口里写适配逻辑，并调用父类方法。

## 对象适配器

通过组合实现

1. 适配器类实现被适配接口
2. 把需要适配的类，作为一个成员变量
3. 在需要实现的接口方法里，调用对应的成员变量方法，实现适配

## 使用场景

1. 封装有缺陷的接口设计。
2. 统一多个类的接口设计。
3. 替换依赖的外部系统。
4. 兼容老版本接口。
5. 适配不同格式的数据。

## 门面模式

