# 单体系统

优点:不会发生进程间的通信,部署简单
缺点:缺少隔离和自治能力,当发生一些内存错误就会导致
过度消耗进程空间内的公共资源.需要停机维护.

# 事件驱动架构

在子系统之间建立一套事件队列管道（Event Queues），
来自系统外部的消息将以事件的形式发送到管道中，
各个子系统可以从管道里获取自己感兴趣、可以处理的事件消息，
也可以为事件新增或者是修改其中的附加信息，
甚至还可以自己发布一些新的事件到管道队列中去。

# 无服务Serverless

只涉及了后端设施（Backend）和函数（Function）两块内容.
后端设施:数据库,消息队列等
函数:一些功能化的函数,目前ai场景居多,比如对图片的各种操作.

# rpc

rpc主要的三个问题

1. 如何表示数据:独立于语言的数据格式(json,Protocol Buffers).
2. 如何传递数据(网络tcp,udp).
3. 如何表示方法(方法名)

# RESTful

一种面向资源的表达方式.是一种表达风格.
REST 的基本思想是面向资源来抽象问题，它与此前流行的面向过程的编程思想，在抽象主体上有本质的差别。

# 本地事务

数据库状态一致性.
原子性:同一个事中,对多个数据的修改,要么同时成功,要么一起被撤销.
隔离性:不同事务处理过程中,事务保证了各自业务正在读写的数据相互独立,不会彼此影响
持久性:事务应当保证所有被成功提交的数据修改都能正确地被持久化,不丢失数据.
A,I,D是手段.C是目的(一致性).

## 原子性,持久性

适用于单个数据,单个数据源.
为了能够崩溃恢复就需要存储日志:redo log,bin log
首先，日志一旦成功写入 Commit Record，那整个事务就是成功的，即使修改数据时崩溃了，重启后根据已经写入磁盘的日志信息恢复现场、继续修改数据即可，这保证了持久性。
其次，如果日志没有写入成功就发生崩溃，系统重启后会看到一部分没有 Commit Record
的日志，那将这部分日志标记为回滚状态即可，整个事务就像完全没有发生过一样，这保证了原子性。

数据的修改必须在提交日志之后,为了提高性能,在事务(日志)提交前
就修改数据,需要添加undo log,这样在数据修到一半,需要恢复的时候
就可找到之前的数据.

FORCE：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE，如果不强制变动数据必须同时完成写入则称为 NO-FORCE。
现实中绝大多数数据库采用的都是 NO-FORCE 策略，只要有了日志，变动数据随时可以持久化，从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。
STEAL：在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。
从优化磁盘 I/O 性能考虑，允许数据提前写入，有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。

## 隔离性

现代数据库一般都会提供三种锁

1. 写锁:也叫x锁,排他锁,持有写锁的事务,才能对数据写入操作,数据加持写锁的时候,其他事务不能修改,也不施加读锁
2. 读锁:也叫s锁,多个事务可以对同一个数据添加读锁,数据加上读锁之后就无法再添加写锁.如果只有一个事务添加了读锁,可以升级为写锁
3. 范围锁:gap lock+next key

### 可重复读

加的读锁写锁,在事务结束后释放

### 读已提交

写锁会在事务结束后释放,读锁在操作结束后释放

### 读未提交

只加写锁,不加读锁

### mvcc

mvcc是一种读取优化策略,"无锁"是指不需要加读锁,思路是任何修改都不会覆盖之前的数据,
而是生成一个新副本与老版本共存.

MVCC 是只针对“读 + 写”场景的优化，如果是两个事务同时修改数据，
即“写 + 写”的情况，那就没有多少优化的空间了，加锁几乎是唯一可行的解决方案。

# 全局事务
