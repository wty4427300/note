# 树

## 二叉树有几种存储方式？什么样的二叉树适合用数组来存储？

树里面每个元素叫节点，同一个父节点下的子节点叫兄弟节点。没有父节点的节点叫做根节点。没有子节点的节点叫做叶子节点。

## 树的高度，深度，层

高度＝节点到子节点的最长路径
深度＝根节点到这个节点所经历的
层数＝节点的深度＋１（因为从１开始不是从０开始）
树的高度＝根节点的高度

## 满二叉树

## 完全二叉树　

除最后一层其他节点必须全部满子节点，最后一层节点全是左子节点

## 存储二叉树有两个方法

１．基于指针或引用的二叉链式存储法，
２．基于数组的顺序存储法。

数组存储比链路存储省内存的原因就在于不需要存子节点指针，而完全二叉树是最适合的一种存储的

## 二叉树的遍历：前序中序后序三种遍历。

前中后，指的是根节点与左右子树节点遍历打印的先后顺序。

前序：根左右
中：左根右
后：左右根

所以说所谓的前中后对应的是根的位置

时间复杂度o(n)

## 遍历一棵树的两种策略

1.深度有限搜索
2.广度优先搜索(就是按层遍历树)

## dfs解法

# 数组

数组开头下标为0是因为它的寻址方式为
当前下标地址a[i]=首地址+i*数据类型的size
由于删除一个元素需要把后面的所有元素向前搬迁，所以在删除的时候可以先标记元素被删除，当内存不够使再真正删除。
从1开始
a[k]_address = base_address + (k-1)*type_size
比从0开始多了一次减法指令。

我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。
当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   如果此时缓存未满，则将此结点直接插入到链表的头部；
   如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部；

fifo 先进先出
lfu 最少使用
lru 最近最少使用

# 快排

得到标记位数后将数组分为了三段
从头到标记位，标记位，从标记位到结尾

# 图

## 图分为:有向图和无向图

无向图有度(degree)的概念,度就是顶点有多少条相关联的边.
有向图中度分为入度（In-degree）和出度（Out-degree）
如果还要记录每一条边的长短,那就需要带权图

## 图的存储

1. 邻接矩阵
   ![](img/graph.webp)
   这样存储虽然直观,但是浪费空间.因为无向图顶点的存储是对角线对称
   的我们只存储一个就可以推断另一个的位置.
2. 邻接表
   即每个顶点对应的链表存储的是该顶点相关联的边.而这种数组套链表的方式就和map差不多.
   邻接表虽然比矩阵节省空间,但是查找对应的关系需要遍历链表,链表的存储方式也是缓存不友好的.
   ps:对应的,为了快速查找也可以将链表换成红黑树等结构.

## BFS（广度优先搜索）

1. 单源最短路径问题：在无权图中，BFS可以用来找到从源节点到所有其他节点的最短路径。这是因为BFS保证首先到达的距离源节点最近的节点。
2. 层次遍历：在树或图的层次结构中，BFS能够按层次顺序访问所有节点，这对于某些类型的问题（如判断是否为二叉平衡树）非常有用。
3. 检测环：通过跟踪每个节点的访问时间，BFS可以帮助检测图中是否存在环。
4. 寻找联通分量：虽然DFS也常用于此，但BFS可以用来确定图中的联通分量，并能提供这些分量的层次信息。

## DFS（深度优先搜索）

1. 连通性问题：DFS可以用来判断图是否连通，通过从一个节点开始遍历，看是否能访问到图中的每一个节点。
2. 回溯搜索：DFS天然适合解决需要“试错”并回溯的问题，比如八皇后问题、迷宫寻路（虽然DFS可能不总是找到最短路径）、括号生成等。
3. 拓扑排序：在有向无环图（DAG）中，DFS可以用来进行拓扑排序，确定任务或事件的执行顺序。
4. 割点和桥的检测：在图中，DFS可以用来找出割点（articulation points）和桥（bridges），这些都是图中重要的结构性特征。
5. 生成树和森林：DFS可以用于构建一个图的生成树，帮助理解图的基本结构。


