# 索引解决的问题
1. 索引极大的减少了扫描行数
2. 避免重排序和临时表
3. 将随机io变成顺序io

select * from user order by age desc;
这条sql会将所有的行加载到内存之后，再按age排序生成一张临时表表
再将这张表排序后返回给客户端如果临时表大于tmp_table_size的值（默认16M）,
那么这张内存临时表会变成磁盘临时表，如果加了索引的话，
索引本身是有顺序的，所以从磁盘读取行数本身就是按照age排序好的
不用生成临时表和额外排序，提升了性能

# 什么时候sql的索引失效呢
1.当sql语句中索引列是函数或者表示式的一部分
即where条件后面跟的是一个计算过程或者函数调用


# 2.隐式类型转换
比如说表里存的是个string但是sql写的是个int就会触发隐式类型转换
就会调用cast函数，于是就触发了上一条规约

# 3.隐式编码转换
如果两张表编码不一致那么当一句sql涉及到这两张表时就会触发隐式的函数调用
转换编码集

因为使用order by导致的全表扫描，加了索引还是全表扫描了，因为select *导致了回表查询

# 什么是回表查询呢
我们都知道普通索引叶子节点存主键id，聚簇索引叶子节点存具体的行的值
我们如果使用聚簇索引查到索引就找相对的行的值
如果使用普通索引就会先找到主键id，然后再走一遍聚簇索引找到具体的记录
这样就走了两次索引查询，故而叫做回表查询

 

