# 什么是虚拟线程？

虚拟线程就是其他语言中的协程（比如go）。

# 为什么要有虚拟线程？

* os不知道用户态如何使用线程，所以jvm会分配一个默认的大小（可以通过-XX:ThreadStackSize修改），通常会比实际使用的要大很多;
* 线程上下文切换要通过内核调度进行，相对更慢;

os线程的开销限制了java程序不能创建太多的线程，导致硬件资源利用不够。其次再java使用线程需要设置线程池
来管理线程，不如go协程使用简单。

![img_8.png](img_8.png)

虚拟线程真正擅长的是等待，等待大量阻塞操作完成。它能提供的是 scale（更高的吞吐量），而不是 speed（更低的延迟）。
虚拟线程最适合的是原来需要更多线程数来处理计算无关业务的场景，典型的就是像web容器、数据库、文件操作一类的IO密集型的应用。

虚拟线程的调用堆栈存在java堆上，而不是os分配的栈区域。

虚拟线程的运行实际上就是两个操作

* 挂载（mount）：挂载虚拟线程意味着将所需的栈帧从堆中临时复制到载体线程的堆栈中，并在挂载时借用载体堆栈执行。

![img.png](img.png)

卸载（unmount）：当在虚拟线程中运行的代码因为 IO、锁等原因阻塞后，它可以从载体线程中卸载，然后将修改的栈帧复制回堆中，从而释放载体线程以进行其他操作（例如运行另一个虚拟线程）。对应的，JDK
中几乎所有的阻塞点都已经过调整，因此当在虚拟线程上遇到阻塞操作时，虚拟线程会从其载体上卸载而不是阻塞。

![img_1.png](img_1.png)

scheduler:可以使用ForkJoinPool可以用。work-stealing + FIFO，性能很好。

![img_2.png](img_2.png)

JDK中的一些阻塞操作不会卸载虚拟线程，因此会阻塞其载体线程。这是因为操作系统级别（例如，许多文件系统操作）或JDK级别（例如，Object.wait()
）的限制。这些阻塞操作的解决方式是，通过临时扩展scheduler的并行性来补偿操作系统线程的捕获。因此，scheduler的ForkJoinPool中的平台线程数量可能暂时超过CPU核数。
