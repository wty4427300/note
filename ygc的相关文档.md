# 1.jmap -dump:format:b,file=heap pid

# 2.ps aux|grep "applicationName" 查看jvm参数

# 3.jmap -heap pid

# 4.思考一下ygc的原理
1.从gc root扫描对象，对存活对象进行标注
2.将存活对象复制到s1区或者晋升到old区

所以ygc的时间过长和幸存代的使用成正比，说名标记和复制的对象很多，所以时间慢幸存代使用也多

# 5.回顾ygc
1.ygc分为三个部分
一个eden区
两个幸存代
大小比例8：1：1

# 6.一些为什么
1.为什么要有新生代？
因为没有新生代的话每次内存回收就需要扫描整个堆

2.为什么新生代用复制算法?
因为新生代对象朝生夕死，90%的独享很快就会被回收，复制算法成本低且没有内存碎片，虽然标记整理算法也可以保证没有碎片，但是新生代清理对象太多，需要大量移动操作

3.为什么有两个survivor
按照传统的复制算法需要两块等大的内存，如果只有一块survivor的话，那么eden和survivor，就需要一样大

4.新生代的实际可用空间是90%
因为有一个块survivor始终被占用

# 7.ygc的触发时机

当eden区空间不足时，就会触发ygc。

1.新对象回先尝试在栈上分配，如果不行则尝试在tlab分配，否则满足大对象条件要求在老年代分配，最后才考虑在eden区分配

2.如果eden区没有合适的空间就会触发ygc

3.ygc时，对eden区和from survivor区的存活对象进行处理，如果满足动态年龄判断的条件或者to survivor空间不够则直接进去老年代。