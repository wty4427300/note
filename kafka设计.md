# 动机

设计为一个统一的平台，用于处理所有实时数据源。
高吞吐，例如实时日志聚合
优雅的处理大数据积压，以便能够支持来自离线系统的定期数据加载
低延迟交付，以便处理更传统的消息传递用例
分区，分布式，实时粗粒，创建新的feed，容错

# 持久性

## 使用文件系统
kafka严重依赖文件系统来存储和缓存消息。人们普遍认为“磁盘很慢”，这使人们怀疑持久性结构能否提供有竞争力的性能。 
事实上，磁盘比人们预期的要慢得多，也快得多，这取决于它们的使用方式;正确设计的磁盘结构通常可以与网络一样快。

在具有六个 7200rpm SATA RAID-5 阵列的 JBOD 配置上，线性写入的性能约为 600MB/秒，但随机写入的性能仅为 100k/秒左右，相差超过 6000 倍。
在某些情况下顺序磁盘访问可能比随机内存访问更快。

当我们使用文件io时，自己在进程中维护进程内缓存，这些数据也会在PageCache中缓存，相当于缓存了两次。

* kafka实在jvm之上构建的，研究过java内存的人都知道
1. 对象内存开销非常高，通常会使存储的数据大小增加一倍（或更糟）。
2. 随着堆内存的增加，java垃圾回收变得越来越繁琐和更缓慢。

所以使用文件系统并依赖PageCache,优于维护内存中缓存和其他结构。存储紧凑的字节结构而不是单个对象，这样做
再 32GB 机器上缓存高达 28-30GB，而不会受到 GC 惩罚。即使重启缓存也是热数据，这也简化了代码因为所有用
于维护缓存和文件系统之间一致性的逻辑现在都在操作系统中。如果您的磁盘使用偏向于线性读取，那么预读会有效地用
每个缓存上的有用数据预先填充此缓存磁盘读取。

## 选择队列为数据结构
为什么使用队列而不适用btrees，因为btrees的操作是ologn，随着数据增加性能降低，而队列操（读取和追加到文件上）作是o1，因此性能和
数据大小完全解耦。

## 效率
### 当消除了磁盘的不良访问，那么此类系统效率低下有两个常见的原因:
1. 小型io操作过多
2. 字节复制过多


* 服务器接受和发送消息，都是多条合并发送，而不是一条一条的发送。
持久化的时候也是一次将消息块附加到日志中
* 使用一种标准化的二进制消息格式
* 消息集合使用相同的格式写入磁盘，所以持久日志块的网络传输，可以使用内核函数
sendfile完成，sendfile提供了高度优化的代码路径 out of pagecache到socket

### 一般情况下数据从文件传输到套接字的通用数据路径
1. 操作系统将数据从磁盘读取到内核空间中的页面缓存中
2. 应用程序将数据从内核空间读取到用户空间缓冲区中
3. 应用程序将数据写回内核空间的套接字缓冲区
4. 操作系统将数据从套接字缓冲区复制到网卡缓冲区，在那里通过网络发送数据

* 这一系列操作有四个缓存两个系统调用，显然是低效的。使用sendfile允许操作系统将数据
从pagecache直接发送到网络，避免了过多复制。

* pagecache 和 sendfile 的这种组合意味着，在消费者连接的Kafka集群上，
你将在磁盘上看不到任何读取活动，因为它们将完全从缓存中提供数据。 
