# 事物的四大特性
1.原子性：是一个不可分割的整体，要么全都执行，要么全不执行。执行出错事务回滚。
2.隔离性：同一时间，只允许一个事务请求同一组数据。不同事物彼此之间没有干扰。
3。一致性：事务开始前和开始后。数据库的完整性约束没有被破坏。
4.事务完成后落盘，不能回滚。

# 事务的并发问题
脏读：事务A读取了事务B的数据，事务B回滚，A读到了脏数据。
幻读:事务A修改表A，事务B向表A插入了一条数据，事务A修改完发现表A有一条记录还没有被修改。
不可重读：事务Ａ不断的读表Ａ，事务Ｂ不断的修改表Ａ。导致事务Ａ读取到的数据不一致。

# 四大隔离级别

１．读未提交。就是读到脏数据
２．读已提交。就是要等另一个事务提交完了，才能够读取。解决了脏读问题
３．可重读。保证了每次的读到的数据一致，不管其他事务是否已经提交。解决了不可重读问题
４．串行化。开启一个序列化事务，其他事务的对数据表的写操作都会挂起。

# 全局锁
1.备份的时候需要全局锁,为了备份的逻辑视图完整性.
但是由mvcc实现可重复读是可以保证获取一致性视图的,所以可以不用全局锁.

# 表级锁
分两种:表锁,元数据锁(mdl).
表锁lock table需要显示的执行

mdl在访问一个表的时候会自动添加,以确保读写的正确性.
当对一个表做增删改查操作的时候，加 MDL 读锁
当要对表做结构变更操作的时候，加 MDL 写锁。

读锁不互斥,所以可以有多个线程对表进行增删改查
读写,写写 互斥,所以改变表结构同时间只能有一个线程执行

# 联合索引
实际生效是联合索引+主键索引
比如(a,b)+(c,b)=(a,b,c)

# 行锁
行锁是由引擎层各自实现的.

# rr可重复读隔离级别下
读是事务开始时的read-view(视图)读.
写是,读后写,即已经提交的事务的更新是可以看到的,保证更新不丢失.

# row的版本
row可能会有多个版本,版本由trx_id(事务id)表示.

# 索引的遍历过程
层级遍历找叶子节点,叶内数据二分查找.

# innodb按页从磁盘获取数据,默认一页16k

# change buffer
数据页在内存里的时候就直接更新,如果数据页不在内存里,就缓存在change buffer里面.在下次
查询需要访问这个数据页的时候,将数据页读取到内存,然后执行change buffer中和这个页相关的
操作.除了查询,后台线程也会定期merge change buffer.

唯一索引需要执行唯一性判断,所以需要一定需要读取数据页,直接修改即可,不需要change buffer.
chang buffer使用的是buffer pool的内存,不能无限增加,通过配置可以修改其占据的百分比.

所以普通索引的更新比唯一索引快,因为可以直接使用change buffer.

# 关于记录复用和page复用
记录复用只要符合二分法得到的查询范围,就可以复用
例如 200 400 600 三个记录删除了400,在插入一条500,那么原来400的记录空间就是可以复用的

# 删除导致的空洞怎么处理
innodb是标记删除,所可以通过重建标,来排除空洞,建立一个新表,把数据copy过去,删除旧标.

# online ddl
建立一个临时文件，扫描表 A 主键的所有数据页；
用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；
生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
用临时文件替换表 A 的数据文件。

# 两阶段提交
先写数据,在写redo log,最后写binlog.这是完整的过程.

# 回答：一个事务的 binlog 是有完整格式的：
statement 格式的 binlog，最后会有 COMMIT；
row 格式的 binlog，最后会有一个 XID event。

# 为什么需要两阶段提交
redo log是作用于innodb的一旦提交就无法回滚,如果这时候binlog写入失败的话,
redo log又无法回滚,数据就和binlog不一致了.两阶段就是为了给所有人一个犯错的
机会,当所有人都准备好再一起提交.

# 数据是从那落盘的
buffer pool,redo log只存page级别的数据变更.innodb如果判断一个数据页,
在崩溃重启的时候丢失了更新,就会先去磁盘里加载页,然后从redo log里更新页

先写redo log buffer,在commit的时候再去写具体的buffer.

