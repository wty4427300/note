# 极客时间的课程和南大的计算机基础课差不多,都是搓cpu的课程

## cisc & risc

1.芯片是所有半导体元器件的统称,cpu也只是芯片的一种而已.

2.cpu的工作流程分为5个步骤:
取指令,指令译码,执行指令,访问读取数据,结果写回.

3.cisc:
复杂指令集体系结构

4.risc:
精简指令集计算机体系结构
分为基本指令集和可扩展指令集,按需组合自由扩展

5.Verilog 语言的 module 模块化
自顶向下的一个模块树

## 4.硬件语言基础

cpu上做逻辑控制,大概有两种
1.时序逻辑.
2.组合逻辑.

Iverilog 是一个对 Verilog 进行编译和仿真的工具，
而 GTKWave 是一个查看仿真数据波形的工具.
安装 Iverilog：sudo apt-get install iverilog
安装 GTKWave：sudo apt-get install gtkwave

# 6.迷你cpu架构设计和取指令实现

pre_if:模块分支预测或预读取模块,如果上一条指令是分支跳转,则产生跳转pc
后,并对下一条指令进行预读取.

if_id:取指到译码之间的模块,指令预读之后会先送入if_id模块,如果当前流水线
没有发出指令清楚,if_id模块就会吧指令送到译码模块.

id_ex:译码到执行之间的模块,用于完成指令译码之后的寄存器索引值,以及指令执行的功能信息,
根据流水线控模块的控制信号,选择性的发送给执行模块去执行.

ex_mem:将执行之后将数据写进存储器,或者从中读取数据.

mem_wb:把运算结果或从存储器读出的数据,写回到通用寄存器.

# 7.如何实现指令译码模块

在risc-v中无论何种类型的指令
0-6位都是opcode,译码过程中,通过opcode对应的标识,
产生各种译码后的控制指令.
译码可以得到两种指令信号.
1.译码后产生的指令执行控制信号.
2.指令源码中提取的数据信息,如立即数,寄存器索引,功能码等等

当指令发生冲突的时候就需要清楚流水线的中的指令(这里的冲突到底是什么样子的,
还不太理解).
s,j,b型指令的立即数设置为不连续,是为了让rs1,rs2,rd寄存器的位置保持固定,
从而提高流水线的效率.不连续的立即数,只要在译码的时候拼接就好了.

# 9.CPU流水线的访存阶段

数据冒险

# 10.cpu写回模块

控制冒险:下一步的行为,修要依赖上一条指令的执行结果.
分支预测:直接给出跳转后的地址,如果不跳转,到达访存阶段时flush清0并更新pc值即可

# 11.让cpu跑起来

cpu通过总线(bus)和其他设备交互,这是一个一对多(主从结构)
只读存储器 ROM
随机访问存储器 RAM
通用异步收发传输器 UART(是电子设备间进行异步通信的常用模块)

# 14.c语言的执行逻辑

声明+定义

# 15.c与汇编
