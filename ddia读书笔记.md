# ddia

## 软件的重点就是

可靠性(容错)
可扩展性(量大了,可横向扩展)
可维护性(代码规范,抽象分层好)

# 第一章

1.讲了一个现代应用系统的基本架构和对软件来讲至关重要的三个问题：可靠性，可扩展性，可维护性。中位数的性能判定法。总之哦，好像和我这种搬砖的离的太远了。还有扩展在水平（加机器）和垂直（升级机器）之间做取舍。

# 第二章

1.nosql的诞生
讲了一下nosql的诞生和其优点:更好的可伸缩和更大的吞吐量,以及一些关系所不支持的特殊的查询操作.

2.对象关系不匹配
即数据库存储的结构(table)和应用代码中的对象不匹配需要一层转换层(orm框架),存储json(或者xml这种结构化的格式)
虽然可以在一定程度上减少这种不匹配,但是大大提高了局部修改的代价,且降低了条件查询的能力(es的倒排索引是解决方案之一)
,因为一对多的数据是一个树状结构用json可以获得比关系型存储更好的表达性.但是这样在一行中存储冗余信息的方式又不符合关系性存储的规范,所以还是要根据实际情况去取舍.虽然json可以很好的表达一对多的关系,但却没法表达多对多的关系,这是文档结构无法逃避的缺点

大部分情况下当我们去要引用其他table的信息的时候我们都会存储其id这样相当于存储了对应数据的引用,其内容发生改变的时候其他的引用了该表的表无需进行修改,但是有些时候也需要存储非引用的冗余字段,因为这些数据可能会被delete,这时我们存储的冗余字段就相当于当时快照了.但是就需要考虑这些的数据的一致性问题,即发生更新时需要,将所有的副本都更新.所以这类问题可以归属为副本问题.

网络模型
暂时给我感觉就是图数据库,查询数据需要有查询的路径,要不然就只能从多条路径中自己去取舍.

文档模型中的模式灵活性
这里说文档数据库是不会强制存储的数据的但是可以通过模式的选择决定要不要规定文档的基本格式即schema(
es需要建立索引已经是显式啦!),当然现在关系性数据库也支持文档类型了比如pg.

# 第三章

讲了lsm tree和b+,行存列存,列存优化,OLTP主要是对数据的增删改,OLAP是对数据的查询。

# 第四章

讲了一些编码格式,明文格式(如json),以及降低可读性减小数据大小的二进制格式,还有rpc如何做向前向后兼容的(
这类东西是第一次系统的看,过一段时间估计就忘了).

# 第五章

这部讲的是分布式下数据复制问题,如何保障一致性,和6.824搭配使用更佳.

# 第六章

讲分区,分库分表,负载均衡,冷热分离等等这些都是分区的手段.

# 第七章

事务的定义以及实现原理.
读已提交.需要保存数据的至少两个版本,之前已经提交的版本(旧),和当前正在提交中的版本(新).

update被翻译为delete and insert

观察一致性快照的可见性规则
1.当前事务开始的时候,尚未提交或者中止的事务的写入会被忽略
2.被中止事务所执行的写入会被忽略
3.具有较晚事务id的,即事务id大于当前事务的id,这些事务的写入会被忽略
4.所有写入对应用都是可见的
5.读事务开始时，创建该对象的事务已经提交。对象未被标记为删除，或如果被标记为删除，请求删除的事务在读事务开始时尚未提交。

# 第八章

分布式系统的麻烦
1.部分节点失效
2.异步,拥塞控制使得网络不可靠
3.需要同步和物理石英石时钟的变化使得时钟不可靠

# 第九章

