# cap

1.分区容错
2.可用性
3.一致性

# raft的一切

## 1.关键模块

领导人选举，日志复制和安全性

## 2.重点记录

1.强领导者:日志条目只能从领导者发送给其他服务器。
2.领导选举:使用一个随机计时器来选举领导者。

## 3.复制状态机

重点：
1.保证日志相同
2.5个节点的集群可以容忍两个节点的失败。

## 4.paxos的问题

说白了就太难理解了，有没有标准实现。

## 5.为了可理解性的设计

1.日志不可以有空洞
2.随机化去简化 Raft 中领导人选举算法（这一句暂时没什么直接的理解）

## 6.raft的一致性算法

1.选举领导人。由领导人负责管理日志复制的责任来实现一致性。

2.这一段主要讲了一些选举的条件

## 7.raft基础

1.5个节点最多允许失效2个（节点数为2n+1，失效容忍数不能超过节点的一半）。
2.服务的节点角色：领导人，跟随者，候选人
3.正常情况下只允许一个领导人，其他都是跟随者。
4.跟随者都是被动的，只是简单的处理领导和候选的请求。领导人处理客户端的请求
4.如果客户端的请求打到了跟随者，跟随者会把请求重定向到领导人。
5.在一个给定的任其term内只有最多只有一个领导者。
6.term任期在raft中充当逻辑时钟划分整个集群的时间线。
7.如果一个节点发现自己的任期过期了，改节点会立马变成跟随者状态。同理一个节点受到一个过期的请求，那么该节点会直接拒绝这个请求。
8.raft的rpc只有两种。投票（RequestVote）附加条目（AppendEntries）

## 8.领导人选举

1.领导者周期性的向所有跟随者发送心跳包，如果一个跟随者在一段时间里没有受到任何消息，也就是超时选举，那么他就会认为系统中没有可用的领导者，并且发起选举选出心的领导者。

2.开始选举跟随者的term需要+1，并将自己的角色转换为候选人。然后并行的向集群中的其他服务器发送投票rpc.候选人状态会保持直到三件事情之一发生
1.他自己赢得了这次选举
2.其他服务器成为了领导者
3.一段时间后没有任何人获胜（选举超时）

3.一个任期内只能投票一次，一旦某个候选人成为领导人，那么他就会给其他服务器发送心跳消息来建立自己的权威并阻止新的领导人诞生。

4.为了防止投票被均匀瓜分导致选举失败，raft使用随机选举超时时间解决。选举时间是在150-300毫秒这个区间随机选择的。

## 9.日志复制

1.日志是由指令和任期组成的，每一条指令也有自己的整数索引。

2.leader先把指令附加到日志里面去，然后同过rpc同步到其他服务器。当日志被完整的复制，领导人就会应用这条日志到状态机中，然后把执行结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断重复尝试附加日志的rpc直到所有跟随者最终都储存了所有的日志条目。

3.被应用到状态机的日志叫做已提交日志。

4.领导人的崩溃会使日志变的不一致。这种不一致的解决方案是使用强制复制领导人的日志解决的，这意味着跟随者的冲突的日志条目会被领导人的日志覆盖。

首先要开始检查第一次产生冲突的索引位置，然后删除跟随者从此往后的日志条目并复制领导人从此往后的日志，从而达到日志的一致性。

5.当一个领导人获得权利的时候首先应该初始化自己的nextIndex（自己最后的一条日志的索引加1）。

6.如果跟随者日志和领导不一致那么rpc的一致性检测就会失败，此时领导人就是减小nextIndex并进行重试，直到找到一致日志为止，之后就会像上面提到的那样删除冲突日志并重新复制领导人日志。

## 10.安全性

1.选举限制
1.如何比较两份日志的新旧？
通过最后一条日志的索引和任期比较。即任期相同的情况下日志长的日志新

## 11.集群成员变化

大概是在讲脑裂了

日志分为两种：
1.普通指令日志
2.集群配置日志

## 12.日志压缩

1.为什么要日志压缩？
因为日志会一直增长，而我们的存储资源却不是无限的。

2.快照是简单的压缩方法，raft保存最新的已提交的日志条目的索引和任期作为快照内容。

3.快照操作后的第一次附加日志请求时需要一致性检查，需要快最后提交的日志条目的任期和索引，所以这个数据需要保存在快照里。如果最新的快照保存成功就可以丢弃之前快照，论文里还说了可以丢弃整个日志。这里暂时保持怀疑。使用快照重置状态机以及加载快照的集群配置。

4.领导人给落后的跟随者发送快照安装的rpc.这样跟随就就可以追上集群的进度。这时候快照的指令一定比日志新，此时就可以丢弃整个日志了。和上面的内容对应了，解决了我的疑惑

## 13.客户端交互

1.客户端启动的时候发送的请求可能不是发给领导人的，那么当前服务器就会拒绝客户端的请求并且提供最近的领导人的信息。如果领导人崩溃了，那么客户端的请求就会超时。之后客户端重试挑选服务器的过程。

2.如果领导在提交日志之后相应客户端之前崩溃了，那么客户端会向新的领导人重试这条指令，导致指令被再次执行，解决方案请求附加唯一id。只读操作直接执行而不需要记录日志。但是一个领导人在返回结果的时候可能已经被作废了，这时候已经有新的领导人了，如果执行成功就会返回脏数据。
1.领导人在任期开始的时候需要提交一个没有操作的空日志，即只有index和term的no-op日志
2.领导人在处理制度请求的时候必须检察自己是否被废除了。

## 14.自己的感悟

1.选举就是为了保证上一任提交的完整性。
2.leader保证本任期的提交。

一个前置节点和本节点将整个流程串联起来就是一个类似链表的设计理念。

## 15.随便写点

心跳100ms，超时时间可以设置300ms-700ms吗？

# paxos

## 是什么

在分布式系统中保证多副本数据强一致的算法.

## paxos有啥用?

没有paxos的一堆机器, 叫做分布式;
有paxos协同的一堆机器, 叫分布式系统.

## 一些不靠谱的复制策略

### 主从异步复制

1. 主接到写请求
2. 主写入本磁盘
3. 主给客户端应答'ok'
4. 主复制数据到从库

缺点:主磁盘在复制前损坏,数据丢失.

### 主从同步复制

1. 主接到写请求
2. 主复制日志到从库
3. 从库可能堵塞
4. 客户端一直等待应答'ok',直到所有从库返回.

缺点:一个失联节点造成整个系统不可用.

### 主从半同步复制

1. 主接到写请求.
2. 主复制日志到从库.
3. 从库这时可能阻塞了.
4. 如果1<=x<=n个从库返回'ok',则返回客户端'ok'

缺点:可能任何从库数据都不完整.

### 多数派写

即每条数据必须写入半数以上的机器,每次读取必须检查半数以上的机器是否有这条
数据.

1. 客户端写入w>=n/2+1个节点,不需要主
2. 多数派读:w+r>n;r>=n/2+1
3. 最多容忍(n-1)/2个节点损坏

缺点:更新时数据不一致.

例子1:
node-1, node-2都写入了a=x,
下一次更新时node-2, node-3写入了a=y.
这时, 一个要进行读取a的客户端如果联系到了node-1和node-2, 它将看到2条不同的数据.
为了不产生歧义,需要添加一个全局时间戳,选择更大的时间戳,忽略更小的时间戳.
这样就看到了 a=x1,a=y2,通过比较时间戳发现y是新数据所以忽略a=x1.

例子2:
当客户端没有完成一多数派写入,客户端进程就挂掉了
a=x₁写入了node-1和node-2, a=y₂时只有node-3 写成功了,
然后客户端进程就挂掉了.
这时另一个读取的客户端来了,
如果它联系到node-1和node-2, 那它得到的结果是a=x₁.
如果它联系到node-2和node-3, 那它得到的结果是a=y₂.
整个系统对外部提供的信息仍然是不一致的.

## paxos是什么?

1. 一个可靠的存储系统:基于多数派读写
2. 每个paxos实例用来存储一个值
3. 用2轮rpc来确定一个值
4. 一个值'确定'后不能被修改
5. '确定'指被多数派接受写入
6. 强一致性

## 一些概念

Proposer 可以理解为客户端.
Acceptor 可以理解为存储节点.
Quorum 在99%的场景里都是指多数派, 也就是半数以上的Acceptor.
Round 用来标识一次paxos算法实例, 每个round是2次多数派读写:
算法描述里分别用phase-1和phase-2标识. 同时为了简单和明确,
算法中也规定了每个Proposer都必须生成全局单调递增的round,
这样round既能用来区分先后也能用来区分不同的Proposer(客户端).

1. last_rnd 是Acceptor记住的最后一次进行写前读取的Proposer(客户端)是谁, 以此来决定谁可以在后面真正把一个值写到存储中.
2. v 是最后被写入的值.
3. vrnd 跟v是一对, 它记录了在哪个Round中v被写入了.

## phase

### phase-1


### phase-2

