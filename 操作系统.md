# 1.机组

cpu：
cu（Control unit）
ALU（算数，逻辑单元）
寄存器（）

总线

io桥 接总线

外设 接总线

2.哈佛结构
数据和指令分离（两块内存）

3.程序的存储与执行
hello.c->a.out->disk->总线->io桥->memory->cpu->
cpu:
取指（指令拿到寄存器里面）
翻码
执行

一个bit可以存0,1
那么4bit就可以表示
2*2*2*2=16

# 2.isa和risc-v

isa：指令集架构 相当于接口规范

# 3.线程库 现代处理器和宽松内存模型

线程共享全局变量和堆,独占自己的局部变量(frame)

strace ./a.out(可以查看系统调用);
objdump -d  a.o(查看汇编)
gdb layout(看汇编)
asm volatile("":::"memory") 内存屏障

现代处理器:处理器也是动态编译器.
uop指令:处理器维护了一个有向无环图,处理要么尽可能多的将指令放进去,要么将尽可能多的指令拿出来执行.

# 4.peterson算法,模型检验与软件自动化工具

1.处理器默认不保证load+store的原子性.所以只有在这个保证的基础下,才可以很好的实现基于共享内存的互斥算法(互斥锁).

# 5.并发控制(互斥,自旋和futex)

1.使用原子指令,那么原子指令之前的store都会被写入内存,写入内存就保证了,全局的可见性.在就是保证了load/store不与原子指令乱序.

2.Load-Reserved/Store-Conditional (LR/SC)(risc-v的新设计)
LR: 在内存上标记 reserved (盯上你了)，中断、其他处理器写入都会导致标记消除
SC: 如果 “盯上” 未被解除，则写入.

3.自旋(共享变量)会触发处理器间的缓存同步,延迟增加.

4.除了进入临界区的线程,其他处理器上的线程都在 空转.

5.争抢锁的处理器越多,利用率越低.

6.获得自旋锁的线程可能被操作系统切换出去操作系统不 “感知” 线程在做什么(但为什么不能呢？)实现 100% 的资源浪费.
解决方案是实现内核级别的自旋锁,即syscall.因为操作系统本可以阻止中断,阻止上下文切换,让线程原子的执行完毕,将自旋的副作用降到最低.

7.futex=自旋+互斥.

# 6. 并发控制:同步(条件变量,信号量,生产者和哲学家吃饭问题)

wait(&lock),因为wait要解锁,所以需要吧当前获取的锁传进去.

# 7.真实世界的并发编程

1.viu(工具,可以用unicode打印图片).
2.协程的好处:保存的寄存器和栈更少,省去了进入操作系统的开销(即进入内核态).

# 8.并发bug和应对

1.死锁:就是线程互相在等待,无法执行.
2.死锁产生的四个必要条件
互斥:一个资源每次只能被一个进程使用.
请求与保持:一个进程请求资源阻塞时,不释放已获得的资源.
不剥夺:进程已获得的资源不能强行剥夺.
循环等待:若干进程之间形成头尾相接的循环等待资源关系.
3.如果锁是顺序的,且线程获取锁也是顺序的.
4.维护锁的图,根据图来做运行时检测.
5.kasan内存问题检查工具.

# 9.操作系统的状态机模型

1.x86在cpu reset的时候
cr0寄存器->16bit
加载512字节的mbr加载到7c00内存 uefi
经过几个阶段加载之后操作系统模型开始执行

# 10.状态机模型的应用

gdb
layout src调试源代码
layout asm调试汇编
可以用gdb查看局部变量,全局变量等等

record full记录程序的状态
record stop停止记录
reserve-step/reserve-stepi 在记录中调试,这样就可以做到debug后退功能类似数据库中redo log.

记录初始状态+非确定指令条数+结果(这些就可以完整的复现)

# 11.操作系统上的进程

fork就是对状态机的复制
execve就是对复制的状态机的初始化
exit就是删除状态机

# 12.进程的地址空间

vdso不进入内核就执行系统调用
