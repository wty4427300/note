# 锁（Lock）

锁是一种同步机制，用于确保在同一时间只有一个进程或线程可以访问共享资源。其主要特性包括：

互斥性：同一时刻只能有一个线程持有锁。
阻塞性：如果一个线程尝试获取已经被其他线程持有的锁，则该线程会被阻塞，直到锁被释放为止。这可能导致死锁、优先级反转等问题，尤其是在没有正确管理锁的情况下。
例如，典型的锁API可能包含Lock()和Unlock()方法。当一个线程调用Lock()时，它可能会因为锁已被占用而进入等待状态，直到锁可用并成功获取锁。

# 无锁（Lock-Free）

无锁编程指的是不使用传统的锁机制来实现同步的一种编程方式。无锁算法设计的目标是保证系统能够满足以下性质之一或多个：

无限经常最终会完成（Infinitely Often Some Method Call Finishes in a Finite Number of
Steps）：这意味着，在任何给定的时间点，至少有一个正在进行的操作将在有限步骤内完成。即使某些线程被暂停或延迟，也不会阻止其他线程继续前进。
Obstruction-Free：在没有任何其他线程干扰的情况下，每个线程都能在有限步数内完成其操作。
Lock-Free：不仅要求每个线程能在没有干扰的情况下完成，而且在整个系统中，总是有一些线程能够在有限时间内取得进展。
Wait-Free：更进一步，每个线程都能够在固定的、有限的步骤内完成其操作，不受其他线程的影响。
例如，在无锁编程中常用的原子操作如比较并交换（Compare-And-Swap, CAS）、加载链接/条件存储（Load-Linked/Store-Conditional,
LL/SC）等机制，允许程序在没有传统意义上的锁的情况下进行同步。这些原语通常设计为确保在一定次数的尝试后总能成功执行某个操作，而不是让线程无限期地等待。