# 对无锁的思考

首先你先认真想一下，锁是什么东西？如果让你设计一个锁，它应该有怎样的 API，要满足怎样的性质。API 好说，Lock 和
Unlock。它需要满足这样的性质：1. 同一时刻，只有一个进程能获取到锁2. 在锁已经一个进程被获取之后，其他进程执行 Lock 会被阻塞，直到锁被
Unlock 释放这里很关键的一点就是，锁被一个进程获取之后，其他进程可能会无限期地阻塞在 Lock
上面，只要不释放（例如持有锁的进程直接被暂停了），那其他线程都可能被一直阻塞。然后原子变量是不存在无限期地阻塞的。原子变量不管底层是锁总线还是monitor，总会有一个进程能在一定的步骤之后成功修改。你可能会想，CPU
底层实现原子操作都需要锁总线的话，怎么能叫无锁呢？这是因为这两种“锁”的性质是不同的。物理上有没可能无限期地锁总线呢？有可能，一直拉高电信号就行。但是没有
CPU 指令暴露这种能力，即使一个原子操作锁总线，但是两个原子操作之间，它是释放的，那就给了其他进程执行的机会。即这个总线锁是保证会在有限步骤后被释放的，不能一直持有，和前一种锁的性质是不同的。lock-free
是禁止掉了第一种可能无限期阻塞的锁。实际上它的定义里可以完全不提及锁，而只是描述系统必须满足的性质（infinitely often some
method call finishes in a finite number of steps）。但是用第一种锁那就不可能满足这个性质，从在实现上禁止掉它。如果你用过
ARM，就会发现它原子操作是需要循环执行 LL 和 SC 指令，直到 SC
成功。两个进程同时循环执行原子递增，其中一个可能会一直失败，但一个失败了另一个必然会成功，不会两个都一直失败，甚至一个进程被
suspend，另一个进程也能继续执行，这就是 lock-free。更严格的定义，可以找下obstruction-free、 lock-free、 wait-free
相关文章。当你明白上面的定义之后，就应该能理解它和粒度无关。你用 mutex 保护一个int，粒度也原子变量一样细，那也不是无锁。 